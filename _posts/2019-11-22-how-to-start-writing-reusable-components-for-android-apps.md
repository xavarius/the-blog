---
layout: default
title: "How to start writing reusable components for Android apps?"
date: 2019-11-22

<section name="0e5b" class="section section--body section--first"><div class="section-content"><div class="section-inner sectionLayout--insetColumn">![Reusable SpaceX rockets. Credits to SpaceX](/assets/1*tA0R1UunvGr1H3AovQp9JA.jpeg)<h3 name="9469" id="9469" class="graf graf--h3 graf-after--figure graf--title">How to start writing reusable components for Android apps?</h3><p name="de89" id="de89" class="graf graf--p graf-after--h3"><strong class="markup--strong markup--p-strong">The purpose</strong></p><p name="16f6" id="16f6" class="graf graf--p graf-after--p">For anyone, like myself, interested in building custom, reusable view components for an Android app. And those who had problems with finding good guidelines on the topic.</p><p name="a173" id="a173" class="graf graf--p graf-after--p">I will provide the basic reasoning behind architecting custom reusable views. There won’t be implementation details (code) for many reasons, <br>one of those is my trial to focus on the <em class="markup--em markup--p-em">concept</em> rather than technicalities.</p><p name="5d7f" id="5d7f" class="graf graf--p graf-after--p">Anyway, I hope that after reading this article you will be able to apply those principles to any interface architecture pattern such as MVP, MVC, MVVM <br>or MVI.</p><p name="990d" id="990d" class="graf graf--p graf-after--p">The first part says <em class="markup--em markup--p-em">why and when </em>adapt such technique. <br>You can jump to the second part for the list of recommendations.</p><p name="3c24" id="3c24" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">First, ask yourself a question: Do we need reusable components?</strong></p><p name="9fa5" id="9fa5" class="graf graf--p graf-after--p">IMHO you should be a part of a bigger, long-lasting project to consider doing so. I understand it’s hard to draw a line between MVP/short-term <br>and a long-term project sometimes. It is sometimes also hard to let go of technical nicety such as custom views but please be mature to do so. <br>The following list should help you making a decision.</p>![Definitely a hard nut to crack. via meme generator](/assets/1*8l4Mdcs-At2Q-PM-aJBcbA.jpeg)<p name="5364" id="5364" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">YAYS</em></strong></p><ul class="postList"><li name="87c9" id="87c9" class="graf graf--li graf-after--p">If you’re in a flexible environment where design decisions are done based upon <strong class="markup--strong markup--li-strong">many perspectives </strong>(not just your own) so you can pitch for good UX/UI.</li><li name="4af0" id="4af0" class="graf graf--li graf-after--li">If you see one (or more) view is used (will be used) in many places (reused). Plan for it. Those views should have <em class="markup--em markup--li-em">fairly</em> similar UX/UI to serve as a reusable components. Otherwise, reusing them will be challenging. Again, pitch the team to sustain consistent user experience.</li><li name="b8db" id="b8db" class="graf graf--li graf-after--li">If your teams plans to build extremely custom view like karaoke, <br>piano keyboard, fancy animated overlays, etc.</li><li name="4c0d" id="4c0d" class="graf graf--li graf-after--li">Finally, I have not tested this theory but IMHO if you’re bored and you feel like making an old legacy project interesting. <br>Since writing reusable components is like writing complex new features.</li><li name="4ec2" id="4ec2" class="graf graf--li graf-after--li">If you’re able to deliver business value by creating such components.</li><li name="8e42" id="8e42" class="graf graf--li graf-after--li">If your team plans major refactors and you have time to just play with the product.</li></ul><p name="4d7d" id="4d7d" class="graf graf--p graf-after--li"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">NOPE</em></strong></p><ul class="postList"><li name="c5ba" id="c5ba" class="graf graf--li graf-after--p">POC or MVP cases. Although, MVP cases could be a good playground.</li><li name="562a" id="562a" class="graf graf--li graf-after--li">Small, simple app cases. There are situations where you know an app will be coded once and left as is. BTW Consider going cross-platform with those. Again, nice playground.</li><li name="ef06" id="ef06" class="graf graf--li graf-after--li">An inflexible environment. Design system gave to you up-front instead <br>of being discussed with all parties involved.</li><li name="73b0" id="73b0" class="graf graf--li graf-after--li graf--trailing">Your codebase is not ready to handle reusable components. <br>Please see <strong class="markup--strong markup--li-strong">Prerequisites </strong>section at the very end for few tips. <br>In this case you might have to put some work beforehand in order to <em class="markup--em markup--li-em">enable</em> reusable components.</li></ul></div></div></section><section name="6ebe" class="section section--body"><div class="section-content"><div class="section-inner sectionLayout--insetColumn">![Brace yourself! via meme generator](/assets/1*yuyQNA5y2y7LhGBidiY9IQ.jpeg)<p name="bc0d" id="bc0d" class="graf graf--p graf-after--figure">Ok, so now you’re <strong class="markup--strong markup--p-strong">sure</strong>. Let’s go with recommendations!</p><ol class="postList"><li name="43cc" id="43cc" class="graf graf--li graf-after--p"><strong class="markup--strong markup--li-strong">Custom views</strong></li></ol><p name="b202" id="b202" class="graf graf--p graf-after--li">It could be quite obvious for some and not necessary for some others <br>as I noticed. Deeply research the case of custom views first and try to imagine them as reusable and self-contained components. Don’t be afraid. <br>There are <a href="https://developer.android.com/guide/topics/ui/custom-components" data-href="https://developer.android.com/guide/topics/ui/custom-components" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">plenty of materials</a> to learn how to create simple custom view. <br>Remember, it doesn’t mean you’re responsible for rendering everything yourself. It doesn’t mean you have to create those components from scratch neither. It will be the better and simpler version of what Fragments suppose to be.</p><p name="b3ba" id="b3ba" class="graf graf--p graf-after--p">Think of a custom view as a container (f.ex ViewGroup like FrameLayout) <br>for other components grouped together to <strong class="markup--strong markup--p-strong">serve one purpose</strong>. <br>For example list of results used in couple places, part of product detail screen, or maybe just a grid product item used on different screens of your app, <br>or a search-bar and corresponding list of results. In the Toolbar/bars case <br>be careful. We had a lot of work with extracting Toolbar out of custom view after we realised Toolbar should be a separate, reusable component itself. <br>The important parts are <em class="markup--em markup--p-em">reusability</em>, <em class="markup--em markup--p-em">testability</em> and <em class="markup--em markup--p-em">independency</em>. <br>Decouple your view and controller from everything else, more on this shortly.</p><p name="9cf9" id="9cf9" class="graf graf--p graf-after--p">I would suggest to read about <a href="https://bradfrost.com/blog/post/atomic-web-design/" data-href="https://bradfrost.com/blog/post/atomic-web-design/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Atomic Design</a> in order to imagine the building process better. Basically, think of an any widget like button or label as a basic building block for bigger component. No matter if custom or native one. <br>Then imagine your custom, reusable view (imagine now list of results with reload button) and just compose those two views together. Handle composed views through your view controller or/and communicate through business logic (f.ex in a reactive way but that is not an only option) and you’re good to go.</p><p name="42ba" id="42ba" class="graf graf--p graf-after--p">Please remember, it is complex stuff. Probably the first place you will choose for refactor will be the wrong one. It was the case in my case. <br>My tip would be to go with the simplest view first.</p><p name="4f8f" id="4f8f" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">DON’TS</em></strong><br>Fragments inside “main” fragment.<br><a href="http://hannesdorfmann.com/android/mosby3-mvi-4" data-href="http://hannesdorfmann.com/android/mosby3-mvi-4" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Parent-child</a> relation between views or view controllers. <br>Toolbar as a part of custom view. <br>Navigation bottom bar (iOS Toolbar) as a part of custom view. <br>Coupling. Activity/Fragments does setup for view.</p><p name="09a7" id="09a7" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong"><em class="markup--em markup--p-em">DOS</em></strong><br>Custom view that <strong class="markup--strong markup--p-strong">serves one purpose</strong>. <br>Activity/Fragments just render/show/hide view.</p><p name="7dc3" id="7dc3" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">2. Use platform-native components as much as possible</strong></p><p name="f5e5" id="f5e5" class="graf graf--p graf-after--p">Speaking of custom views, don’t go fully custom if not forced to. <br>Reusing existing components and widgets just makes your life easier <br>and enables you to work on <strong class="markup--strong markup--p-strong">actual, unique to your app business value</strong>. Work alongside with product/UX/UI/your own team to build <em class="markup--em markup--p-em">native-first</em> design systems. In most cases there is no need to go completely custom <br>and I’m sure your client is more than happy to get rid of an animation or fancy screen transition just to <strong class="markup--strong markup--p-strong">get business value on the place</strong>. <br>Ours clients are #trueStory.</p><p name="b12c" id="b12c" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">What do you mean by native components?</em></p><p name="44d0" id="44d0" class="graf graf--p graf-after--p">Google did a great job introducing <a href="https://material.io/develop/android/" data-href="https://material.io/develop/android/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Material Components</a> — guidelines with the corresponding implementation you can reuse in your application.</p><p name="9f83" id="9f83" class="graf graf--p graf-after--p">You could also consider not-views related components like <a href="https://developer.android.com/guide/navigation/navigation-getting-started" data-href="https://developer.android.com/guide/navigation/navigation-getting-started" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Navigation Component</a> which plays nicely with bottom nav bar f.ex. and could simplify your codebase.</p><p name="a969" id="a969" class="graf graf--p graf-after--p">You should take a look on how to compose and reuse themes and styles for your application, <a href="https://www.youtube.com/watch?v=6o3KqyX_tEA&amp;feature=youtu.be" data-href="https://www.youtube.com/watch?v=6o3KqyX_tEA&amp;feature=youtu.be" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">here is a presentation from Googlers on the topic</a>.</p><p name="4541" id="4541" class="graf graf--p graf-after--p">But in the end just reuse old, good widgets and layouts to get things done.</p><p name="7c86" id="7c86" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">3. Use modern app layer (view layer) designs patterns</strong></p><p name="fa99" id="fa99" class="graf graf--p graf-after--p">Yep, and not only for the app layer. Plenty articles on that matter. I recommend you to read <a href="http://hannesdorfmann.com/android/mosby3-mvi-1" data-href="http://hannesdorfmann.com/android/mosby3-mvi-1" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Hannes Dorfmann’s story on MVI</a> since a lot of useful concepts and ideas are there. He elaborates on topics such as how to organise, test, reuse and maintain your code which is not a part of this article but those two topics are strictly related. On the other hand I’m not a fan of tools like <a href="https://github.com/sockeqwe/mosby" data-href="https://github.com/sockeqwe/mosby" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Mosby</a> or <a href="https://github.com/moxy-community/Moxy" data-href="https://github.com/moxy-community/Moxy" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Moxy</a> because I painfully found out they are rather constraining. Inheriting behaviour, state or plugins from base classes was catastrophic in our cases. Refactors and building custom behaviour for new screens were messy tasks and required much effort. Instead, use lifecycle aware components (again, see Android tools) or setup your architecture the way that you can call your business logic anytime. Some people calls it overhead. I would call it simplicity especially most of us happen to use caching.</p><p name="ab41" id="ab41" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">4. Use dependency inversion frameworks extensively</strong></p><p name="f03f" id="f03f" class="graf graf--p graf-after--p">Nowadays, there is world beyond <a href="https://dagger.dev/android" data-href="https://dagger.dev/android" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Dagger</a>. Dagger itself offers quite good support for Android apps also. You can leverage <a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" data-href="https://en.wikipedia.org/wiki/Dependency_inversion_principle" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">dependency inversion principle</a> alongside with framework of your choosing to inject views the same way you are injecting other collaborators like controllers, use cases or data sources. That way you’re decoupling actual view from the place it is rendered.</p><p name="9e6f" id="9e6f" class="graf graf--p graf-after--p">The great news is your custom view is <a href="https://developer.android.com/reference/android/view/View" data-href="https://developer.android.com/reference/android/view/View" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">View</a> implementation which means your Fragment or Activity doesn’t have to know what is rendered inside. Providing View subclasses enables you to use many custom views <strong class="markup--strong markup--p-strong">interchangeable</strong> as particular a component. Voila! Basic A/B testing setup done. Based on condition X you’re providing View Y or Z. Or you want to support multiple apps with one codebase. No worries, just inject different views for different flavours. There is much flexibility in this approach.</p><p name="a22a" id="a22a" class="graf graf--p graf-after--p">The only thing that Fragment or Activity need to do is to add view <br>to the layout (programmatically or through inflated xml if you want to <br>be direct). Don’t over-engineer it since you cannot escape from those <br>few lines. Just show/hide/gone view first based on the state that must <br>be rendered on the screen, and then optimise if necessary. <br>We’re building an app for Android OS 6+ so obviously those devices are quite fast devices. We have not encountered any glitches.</p><p name="6fb1" id="6fb1" class="graf graf--p graf-after--p">Oh, and really focus on cleaning up dependencies declarations like Dagger Modules. If you don’t understand it — spend time on it. Leave readable <br>and understandable legacy to you colleagues. Piling up dependencies are the worst enemy of a clean dependency graph, could lower performance and definitely causes headaches while coding the solution.</p><p name="84c4" id="84c4" class="graf graf--p graf-after--p"><strong class="markup--strong markup--p-strong">5. Infamous parent-child dependency</strong></p><p name="acf3" id="acf3" class="graf graf--p graf-after--p">Don’t introduce <a href="http://hannesdorfmann.com/android/mosby3-mvi-4" data-href="http://hannesdorfmann.com/android/mosby3-mvi-4" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">parent-child dependency</a> in case of custom views. They really need to be testable and independent. You don’t want to create/mock parent view or controller in order to test a child. And you would need to create or mock such instances for UI or unit test eventually. Don’t introduce hidden dependencies like setup of a custom view partially delegated to the Activity/Fragment or parent view. And definitely don’t inject your Activity/Fragment to a custom view which could lead to cycle dependency and memory leaks. That would also mean other developers will not understand how to use your component. It’s not in reusable fashion.</p><p name="3e20" id="3e20" class="graf graf--p graf-after--p graf--trailing">The same goes for view controllers (Presenters, ViewModels, Models, etc). Don’t introduce parent-child link between them. Navigation and analytics are the common mistake — just inject those (hopefully) reusable components to custom view controller instead of calling methods from parent controller in order to do any job like analytics tracking.</p></div></div></section><section name="65c0" class="section section--body"><div class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="ea57" id="ea57" class="graf graf--p graf--leading"><strong class="markup--strong markup--p-strong">In summary, what was the effect of aligning to those principles…</strong></p><p name="29be" id="29be" class="graf graf--p graf-after--p">Simply put, reusable components which could be used anywhere in the app with only small changes to the codebase required. By architecting those properly you should be able to decouple from Android lifecycle hell. <br>TBH we still sometimes need to sync data <em class="markup--em markup--p-em">onResume()</em> or <em class="markup--em markup--p-em">onPause()</em> somehow. That is why we created an abstract class <em class="markup--em markup--p-em">CustomView</em> with <em class="markup--em markup--p-em">onForeground()</em> <br>and <em class="markup--em markup--p-em">onBackground()</em> methods which are then implemented by custom views. We have done it for simplify, since it’s not breaking good architecture rules. We’re still doing our research on this topic. We know some tricks including lifecycle aware components but in the end our goal was to decouple from lifecycle! I will update this article when and if solved.</p><p name="e041" id="e041" class="graf graf--p graf-after--p">So, for example, by creating a list of results which was decoupled completely from other components we were able to switch views inside the screen in couple of lines enabling <strong class="markup--strong markup--p-strong">A/B testing</strong> and easy multiple <strong class="markup--strong markup--p-strong">flavour </strong>handling. It is also in the testing stage, so stay tuned. I’m definitely eager to edit this or write new article after long-term usage of the solution.</p><p name="845a" id="845a" class="graf graf--p graf-after--p graf--trailing">The way to achieve that wasn’t easy. We talked to the client and other devs <br>a lot in order to simplify and learn what is really needed. <br>We started refactor in one place and then thrown away code. And started again because system and requirements were quite complex. But that enabled us to understand business requirements and technical dependencies which opened new perspective on the solution. We knew how to simplify.</p></div></div></section><section name="0de3" class="section section--body"><div class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="b1e4" id="b1e4" class="graf graf--p graf--leading"><strong class="markup--strong markup--p-strong">Prerequisites</strong></p><p name="2492" id="2492" class="graf graf--p graf-after--p">I assumed your codebase is prepared for custom views in a way that many other collaborators are already reusable, testable, independent components. Or at least you’re able to inject them where needed. That would mean Analytics, Navigators, business logic, sensor handlers components and much more. That really depends on your application and you need to resolve it for yourself. Hopefully, by using the above mentioned principles as a reference. Although, there are few basic rules:</p><ul class="postList"><li name="4910" id="4910" class="graf graf--li graf-after--p">Your business logic is separated from views and view controllers.</li><li name="c50f" id="c50f" class="graf graf--li graf-after--li">Your business logic can be easily injected and reused.</li><li name="5246" id="5246" class="graf graf--li graf-after--li">View controllers are decoupled from views and how views are rendered.</li><li name="0146" id="0146" class="graf graf--li graf-after--li">View controllers are <em class="markup--em markup--li-em">framework agnostic</em>.</li><li name="1197" id="1197" class="graf graf--li graf-after--li">View controllers are easily injectable to views.</li><li name="9a88" id="9a88" class="graf graf--li graf-after--li graf--trailing">Views are are easily injectable to Fragments/Activities.</li></ul></div></div></section><section name="9497" class="section section--body"><div class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="079f" id="079f" class="graf graf--p graf--leading"><strong class="markup--strong markup--p-strong">DISCLAIMER</strong></p><p name="e963" id="e963" class="graf graf--p graf-after--p graf--trailing">That is my story behind architecting reusable components for an Android app. I’m not saying it is silver bullet nor the best practise. Still, I consider above rules as a great approach to organise our system. <br>It was <strong class="markup--strong markup--p-strong">the first iteration</strong> we did in <a href="https://tigerspike.com/" data-href="https://tigerspike.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Tigerspike</a> as a part of the larger project so stay tuned for more! Big shout out to my colleagues as they made this article possible. :)</p></div></div></section><section name="8591" class="section section--body section--last"><div class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="d34e" id="d34e" class="graf graf--p graf--leading"><strong class="markup--strong markup--p-strong">PS</strong></p><p name="cd56" id="cd56" class="graf graf--p graf-after--p graf--trailing">I would love to see your comments, ideas and improvements as I’m looking to improve and share knowledge as much as possible. <br>If you want to reach me out I’m based in Wrocław, Poland. <br>From time to time I’m visiting London. <br>Here is my <a href="https://pl.linkedin.com/in/maciejmalak" data-href="https://pl.linkedin.com/in/maciejmalak" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">LinkedIn</a> and <a href="https://twitter.com/monkeydevspl" data-href="https://twitter.com/monkeydevspl" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Twitter</a>.</p></div></div></section>
