<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Be effective with Bitrise CI for Android — lessons I learned the hard way.</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Be effective with Bitrise CI for Android — lessons I learned the hard way.</h1>
</header>
<section data-field="subtitle" class="p-summary">
Ideas around architecture, flavour agnostic unit testing, Gradle usage, keeping your logs and artefacts deployment in order and a few more
</section>
<section data-field="body" class="e-content">
<section name="25d5" class="section section--body section--first"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="2ebe" id="2ebe" class="graf graf--h3 graf--leading graf--title"><strong class="markup--strong markup--h3-strong">Be effective with Bitrise CI for Android — the lessons I learned the hard way.</strong></h3><figure name="389d" id="389d" class="graf graf--figure graf-after--h3 graf--trailing"><img class="graf-image" data-image-id="1*TQOKYOUKm5mDiYlF7cKO1A.png" data-width="2188" data-height="1090" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*TQOKYOUKm5mDiYlF7cKO1A.png"></figure></div></div></section><section name="452c" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="e540" id="e540" class="graf graf--p graf--leading">I won’t elaborate here on how important and crucial for any software development-oriented team the<a href="https://www.thoughtworks.com/continuous-integration" data-href="https://www.thoughtworks.com/continuous-integration" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"> continuous integration</a> (CI) practise is.<br>I’m pretty sure we can all agree on how CI tools support our day to day effectiveness. How they <strong class="markup--strong markup--p-strong">might </strong>save dozens of hours spent on non-essential tasks. Yet, it’s common to present CI tools as a hassle; slow, bulky, <br>and unreliable pipelines bloated with chaotic events instead of fast, maintainable feedback loop configured to support both product quality <br>and team flexibility.</p><p name="4fa2" id="4fa2" class="graf graf--p graf-after--p">As the title implies, our CI process was far from optimal. We learned what “slow and chaotic” means the hard way. Below, you will find an overview <br>of each issue that slowed us down, with full explanation of what the solution was (including code and external links), as well as honest <strong class="markup--strong markup--p-strong">results</strong> measured by minutes.</p><p name="37ec" id="37ec" class="graf graf--p graf-after--p graf--trailing">In this article, you will find discussion surrounding architecture, <em class="markup--em markup--p-em">flavour agnostic</em> unit testing, Gradle usage as well as keeping your logs and artefacts deployment in order. Additionally, at the end of the article, several tips <br>and tricks beyond optimisation will be included. <br>It’s not a step-by-step tutorial. We gathered results that work for us, <br>and <strong class="markup--strong markup--p-strong">you</strong> have to <strong class="markup--strong markup--p-strong">think them through. </strong>If those solutions make sense to you then, and only then, apply them to your environment.</p></div></div></section><section name="fe16" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="1fdb" id="1fdb" class="graf graf--h3 graf--leading">The landscape</h3><p name="f138" id="f138" class="graf graf--p graf-after--h3">In order to fully understand <strong class="markup--strong markup--p-strong">why</strong> we provided a particular optimisation <br>it is crucial to understand how our landscape looked at the time.</p><p name="a290" id="a290" class="graf graf--p graf-after--p">There is<a href="https://nvie.com/posts/a-successful-git-branching-model/" data-href="https://nvie.com/posts/a-successful-git-branching-model/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"> git flow approach</a> in place, which usually means multiple <em class="markup--em markup--p-em">feature </em>branches exist at the same time in a remote repository. There is at least one <em class="markup--em markup--p-em">pull request</em> per story. Each pull request needs to go through an integration<em class="markup--em markup--p-em"> process</em> meaning the newest commit in a pull request triggers a fresh CI build. That’s being done in order to ensure the newest change won’t introduce any flaws. Yep, automation and unit test suites test each <em class="markup--em markup--p-em">software incrementation</em>. Software Engineers in Test (SET) writes automation tests <br>as “a part of“ the feature in some cases.</p><p name="7172" id="7172" class="graf graf--p graf-after--p">We are supporting multiple modules as a part of our architecture. <br>Let’s assume it is a<a href="https://five.agency/android-architecture-part-2-clean-architecture/" data-href="https://five.agency/android-architecture-part-2-clean-architecture/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"> clean-ish architecture</a> with <em class="markup--em markup--p-em">domain</em>, <em class="markup--em markup--p-em">data</em> and <em class="markup--em markup--p-em">app</em> layers packed into separate modules. Each of the modules has its own unit tests suite — between dozens to few hundreds of them per module. We have to support multiple <em class="markup--em markup--p-em">flavours</em> and they differ greatly. Each flavour has <br>a separate set of automation and unit test, although most of them are shared.</p><p name="31e8" id="31e8" class="graf graf--p graf-after--p">When it comes to infrastructure, there is a separate Bitrise workflow for every build type. Also, a separate one for each of: <em class="markup--em markup--p-em">feature</em> development, <br><em class="markup--em markup--p-em">automation</em> efforts, <em class="markup--em markup--p-em">release</em> (<em class="markup--em markup--p-em">tags</em>) activities and after merging feature <br>to the develop. Seeing how many distinct configs we have, there is a need <br>to run multiple builds every day. We can’t and won’t have “infinite” amount <br>of concurrent jobs, so time devoted to each build is very important to us. <br>It’s also important because we <strong class="markup--strong markup--p-strong">value sh*t done the right way</strong>.</p><p name="67f1" id="67f1" class="graf graf--p graf-after--p graf--trailing">The basic measurement that <strong class="markup--strong markup--p-strong">will prove effectiveness here is build time</strong> — both <em class="markup--em markup--p-em">entire</em> build time or a particular step time (such as unit tests step or deploy step).</p></div></div></section><section name="87a7" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="04ca" id="04ca" class="graf graf--h3 graf--leading">Improvements</h3><h4 name="3ef0" id="3ef0" class="graf graf--h4 graf-after--h3">Unit testing</h4><p name="5e7f" id="5e7f" class="graf graf--p graf-after--h4">The most commonly used feedback loop is unit tests suite, in particular <br>if you’re supporting multiple flavours for Android app and you want to be sure that none of the changes would break any of the flavours. <br>Unit tests are supposed to be a fast and reliable feedback loop, which can be automated at the CI level. So, we used docs and tutorials to set them up for <br>all of the flavours. After few changes to CI, we ended up with 30 minutes long unit test step for 3 flavours. <br>Yes, you read it properly: 30 minutes for 3 flavours.</p><p name="d867" id="d867" class="graf graf--p graf-after--p">Ok, let’s fix that.</p><p name="4d40" id="4d40" class="graf graf--p graf-after--p">After a little bit of research it occurred to us that we used two separate steps for unit tests.<a href="https://devcenter.bitrise.io/testing/android-run-a-unit-test/" data-href="https://devcenter.bitrise.io/testing/android-run-a-unit-test/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"> Android unit test step for Bitrise</a> was running <em class="markup--em markup--p-em">app</em> module unit tests.<a href="https://www.bitrise.io/integrations/steps/gradle-unit-test" data-href="https://www.bitrise.io/integrations/steps/gradle-unit-test" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"> Gradle Unit Test</a> step was just running <em class="markup--em markup--p-em">.gradlew test</em> task.</p><figure name="eb84" id="eb84" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*ZDxhzjlV0QFs2JDvktxfuA.png" data-width="681" data-height="87" src="https://cdn-images-1.medium.com/max/800/1*ZDxhzjlV0QFs2JDvktxfuA.png"><figcaption class="imageCaption">Total time for each step in minutes.</figcaption></figure><p name="a2a0" id="a2a0" class="graf graf--p graf-after--figure">What’s wrong with gradle unit test step in our case? According to the Gradle documentation:</p><figure name="853b" id="853b" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*6z7dHF2MnY1nAVjGlLGntQ.png" data-width="934" data-height="144" src="https://cdn-images-1.medium.com/max/800/1*6z7dHF2MnY1nAVjGlLGntQ.png"><figcaption class="imageCaption">Source: <a href="https://docs.gradle.org/current/userguide/command_line_interface.html" data-href="https://docs.gradle.org/current/userguide/command_line_interface.html" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">https://docs.gradle.org/current/userguide/command_line_interface.html</a></figcaption></figure><p name="7cd3" id="7cd3" class="graf graf--p graf-after--figure">In simple terms, <em class="markup--em markup--p-em">./gradlew test</em><a href="https://medium.com/android-testing-daily/running-your-tests-on-the-command-line-with-gradle-bcba78244487" data-href="https://medium.com/android-testing-daily/running-your-tests-on-the-command-line-with-gradle-bcba78244487" class="markup--anchor markup--p-anchor" target="_blank"> triggers <strong class="markup--strong markup--p-strong">dozens </strong>of different <em class="markup--em markup--p-em">test</em> <em class="markup--em markup--p-em">tasks</em></a> from every module. In our case, it triggered both <em class="markup--em markup--p-em">debug</em> and <em class="markup--em markup--p-em">release</em> related tests <br>for every <em class="markup--em markup--p-em">subproject (</em>module<em class="markup--em markup--p-em">)</em>. That’s too much redundancy; consider the final result of <em class="markup--em markup--p-em">./gradlew test </em>command:</p><p name="434a" id="434a" class="graf graf--p graf-after--p"><em class="markup--em markup--p-em">(amount of flavours) x (amount of supported envs) x (amount of modules)</em></p><p name="e084" id="e084" class="graf graf--p graf-after--p">But the amount of tasks triggered is not all we can improve here. <br>I already mentioned we have several modules. Since it’s <em class="markup--em markup--p-em">cleanish architecture, </em>it consists of <em class="markup--em markup--p-em">app</em>, <em class="markup--em markup--p-em">domain</em>, <em class="markup--em markup--p-em">data</em> and <em class="markup--em markup--p-em">api</em> modules. <br>It’s easy to see that some of those modules are <em class="markup--em markup--p-em">flavour agnostic — </em>domain, data and api layers can and should be treated as libraries. Those are <em class="markup--em markup--p-em">external dependencies</em> that <em class="markup--em markup--p-em">could</em> be used via any JVM compatible code. <br>Do we need to run those tests separately for each flavour? <br>Of course we don’t! Where does it lead us?</p><h4 name="cd15" id="cd15" class="graf graf--h4 graf-after--p"><strong class="markup--strong markup--h4-strong">Flavour agnostic unit tests</strong></h4><p name="fba3" id="fba3" class="graf graf--p graf-after--h4">Split <em class="markup--em markup--p-em">flavour dependen</em>t and <em class="markup--em markup--p-em">flavour agnostic</em> unit tests. Gain greater control over how your application is tested. Use<a href="https://www.bitrise.io/integrations/steps/gradle-unit-test" data-href="https://www.bitrise.io/integrations/steps/gradle-unit-test" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"> Gradle Unit Test step</a> in your<a href="https://devcenter.bitrise.io/bitrise-cli/basics-of-bitrise-yml/" data-href="https://devcenter.bitrise.io/bitrise-cli/basics-of-bitrise-yml/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"> Bitrise.yml</a> to run targeted <em class="markup--em markup--p-em">flavour agnostic</em> unit tests, like this:</p><figure name="6d83" id="6d83" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/xavarius/6132a1ed16bdd944d3cbe0e9cf4ca2b3.js"></script><figcaption class="imageCaption">My gist lets you configure module dependent unit testing. Source: <a href="https://gist.github.com/xavarius/6132a1ed16bdd944d3cbe0e9cf4ca2b3" data-href="https://gist.github.com/xavarius/6132a1ed16bdd944d3cbe0e9cf4ca2b3" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">https://gist.github.com/xavarius/6132a1ed16bdd944d3cbe0e9cf4ca2b3</a></figcaption></figure><p name="85a4" id="85a4" class="graf graf--p graf-after--figure">Using <em class="markup--em markup--p-em">unit_test_task </em>attribute enables you to configure a particular task to be run. Basically, any gradle task. You can obviously chain gradle commands, but I want <strong class="markup--strong markup--p-strong">granularity</strong> here. Additionally, the usage of <em class="markup--em markup--p-em">title </em>attribute keeps build logs in order and enables you to track each step separately.</p><figure name="9d3d" id="9d3d" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*SQSkq3ZylChkaKHJxCGHTw.png" data-width="678" data-height="123" src="https://cdn-images-1.medium.com/max/800/1*SQSkq3ZylChkaKHJxCGHTw.png"><figcaption class="imageCaption">The result of applying the above mentioned recommendations. Cleaning up resources gave us unit tests result in seconds instead of minutes.</figcaption></figure><h4 name="cabc" id="cabc" class="graf graf--h4 graf-after--figure">Flavour dependent unit tests</h4><p name="48c9" id="48c9" class="graf graf--p graf-after--h4">The second recommendation relates to<a href="https://devcenter.bitrise.io/testing/android-run-a-unit-test/" data-href="https://devcenter.bitrise.io/testing/android-run-a-unit-test/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"> Android unit test step for Bitrise</a> <br>and how <em class="markup--em markup--p-em">flavour dependent</em> unit tests are managed. In most cases, <br>I would recommend you to run only what you need. But I came to conclusion that ‘run only what you need’ could be counterintuitive in our case.</p><p name="c871" id="c871" class="graf graf--p graf-after--p">It’s <strong class="markup--strong markup--p-strong">really easy</strong> to break one of the flavours by introducing changes to only one of them. That’s why we ended up with running unit tests for every flavour in every build. In addition, the above mentioned set of <em class="markup--em markup--p-em">flavour agnostic </em>tests is triggered. What does it mean when it comes to Bitrise CI setup?</p><figure name="6f88" id="6f88" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/xavarius/d14bb74261ac9cc40f134b20e66f5542.js"></script><figcaption class="imageCaption">Targeted unit tests per flavour. Source: <a href="https://gist.github.com/xavarius/d14bb74261ac9cc40f134b20e66f5542" data-href="https://gist.github.com/xavarius/d14bb74261ac9cc40f134b20e66f5542" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">https://gist.github.com/xavarius/d14bb74261ac9cc40f134b20e66f5542</a></figcaption></figure><p name="3ae5" id="3ae5" class="graf graf--p graf-after--figure">The above snippet runs unit tests for the <em class="markup--em markup--p-em">app </em>module for a particular flavour injected as an<a href="https://devcenter.bitrise.io/builds/env-vars-secret-env-vars/" data-href="https://devcenter.bitrise.io/builds/env-vars-secret-env-vars/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"> <em class="markup--em markup--p-em">environment variable</em></a> and a particular build variant. <br>So, if CI builds only one flavour at time, this snippet is supposed to be triggered three times, once for each flavour. If all of the flavours are built simultaneously, then each flavour should run its own unit tests in order to avoid redundancy and save a few minutes from build. Notice that, before <em class="markup--em markup--p-em">_UnitTestsPerFlavour step, UnitTests_Flavour_Agnostic_Modules </em>step is triggered. It runs flavour agnostic tests, so <em class="markup--em markup--p-em">domain</em>, <em class="markup--em markup--p-em">data and feature </em>modules unit tests. Either way, all unit tests are always validated.</p><p name="c04b" id="c04b" class="graf graf--p graf-after--p">Alternatively to the above setup, you can use the following setup to hardcode which flavour’s unit tests should be run:</p><figure name="da40" id="da40" class="graf graf--figure graf--iframe graf-after--p"><script src="https://gist.github.com/xavarius/4699179027cce14007257d7b17984d55.js"></script></figure><p name="ab20" id="ab20" class="graf graf--p graf-after--figure">That way we’re all covered, no matter if we’re building all the flavours, or just one. Remember, the lesson here is <em class="markup--em markup--p-em">flavour dependent and agnostic</em> unit tests should be triggered <strong class="markup--strong markup--p-strong">once.</strong> There is no redundancy, but there is full coverage. Every software increment is <strong class="markup--strong markup--p-strong">safe</strong>.</p><h4 name="0eb5" id="0eb5" class="graf graf--h4 graf-after--p">Results</h4><p name="f292" id="f292" class="graf graf--p graf-after--h4">We started with around <strong class="markup--strong markup--p-strong">30 minutes</strong> per build.</p><figure name="be30" id="be30" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*ZDxhzjlV0QFs2JDvktxfuA.png" data-width="681" data-height="87" src="https://cdn-images-1.medium.com/max/800/1*ZDxhzjlV0QFs2JDvktxfuA.png"><figcaption class="imageCaption">Total time for unit testing then.</figcaption></figure><p name="f3c5" id="f3c5" class="graf graf--p graf-after--figure">And finished up with the below results when running one flavour.<br><strong class="markup--strong markup--p-strong">Down to ~5/6 minutes per build.</strong></p><figure name="05d2" id="05d2" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*-ah-XIlWh18Ac0-6z7JEXA.jpeg" data-width="678" data-height="238" src="https://cdn-images-1.medium.com/max/800/1*-ah-XIlWh18Ac0-6z7JEXA.jpeg"><figcaption class="imageCaption">Total time for unit testing now.</figcaption></figure><p name="9af5" id="9af5" class="graf graf--p graf-after--figure">And also <strong class="markup--strong markup--p-strong">down to ~3 minutes per build </strong>when running all the flavours <br>at once, which means each flavour is responsible for its own unit tests finally. Yes, that’s a separate config in order to optimise build time even further.</p><figure name="a369" id="a369" class="graf graf--figure graf-after--p graf--trailing"><img class="graf-image" data-image-id="1*eFTwp0OYl-5lIMLpKgx3GA.png" data-width="678" data-height="162" src="https://cdn-images-1.medium.com/max/800/1*eFTwp0OYl-5lIMLpKgx3GA.png"><figcaption class="imageCaption">Total time when running all of the flavours. Build time for those unit tests per one flavour.</figcaption></figure></div></div></section><section name="4902" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="3613" id="3613" class="graf graf--h3 graf--leading">Artefacts Deployment</h3><p name="0175" id="0175" class="graf graf--p graf-after--h3">Review your D<em class="markup--em markup--p-em">eploy to Bitrise.io </em>step. According to the documentation<a href="https://devcenter.bitrise.io/testing/test-reports/" data-href="https://devcenter.bitrise.io/testing/test-reports/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"> [1]</a> <a href="https://www.bitrise.io/integrations/steps/deploy-to-bitrise-io" data-href="https://www.bitrise.io/integrations/steps/deploy-to-bitrise-io" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">[2]</a> <a href="https://devcenter.bitrise.io/testing/device-testing-for-android/" data-href="https://devcenter.bitrise.io/testing/device-testing-for-android/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">[3]</a> for the following steps test reports are deployed automatically:</p><ul class="postList"><li name="9e5e" id="9e5e" class="graf graf--li graf-after--p">Xcode Test for iOS</li><li name="75ec" id="75ec" class="graf graf--li graf-after--li">Android Unit Test</li><li name="548e" id="548e" class="graf graf--li graf-after--li">iOS Device Testing</li><li name="7a55" id="7a55" class="graf graf--li graf-after--li">Virtual Device Testing for Android</li></ul><p name="3f20" id="3f20" class="graf graf--p graf-after--li">As noted in the documentation, by default Android unit and UI tests are deployed to Bitrise directory and are provided via the <em class="markup--em markup--p-em">Test reports</em> tab. They are easily accessible — but the question is — are they really necessary?</p><p name="72cf" id="72cf" class="graf graf--p graf-after--p">We have robust unit tests. They fail rarely in CI because the entire team writes and runs them frequently. On the other hand, it’s easy to check Bitrise for which logs failed.</p><h4 name="9279" id="9279" class="graf graf--h4 graf-after--p">Deciding what to deploy</h4><p name="37f7" id="37f7" class="graf graf--p graf-after--h4">We already changed from<a href="https://devcenter.bitrise.io/testing/android-run-a-unit-test/" data-href="https://devcenter.bitrise.io/testing/android-run-a-unit-test/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"> Android unit test step for Bitrise</a> to<a href="https://www.bitrise.io/integrations/steps/gradle-unit-test" data-href="https://www.bitrise.io/integrations/steps/gradle-unit-test" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"> Gradle Unit Test</a> step which does not deploy unit tests reports automatically. And we want it that way. What about the rest of the artefacts? For <em class="markup--em markup--p-em">automation </em>builds we’ve decided not to deploy any APKs. They are not needed.</p><p name="cb91" id="cb91" class="graf graf--p graf-after--p">We also already know that<a href="https://www.bitrise.io/integrations/steps/virtual-device-testing-for-android" data-href="https://www.bitrise.io/integrations/steps/virtual-device-testing-for-android" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"> Virtual Device Testing for Android</a> step deploys UI tests results into the <em class="markup--em markup--p-em">Test Reports</em> directory. We decided that for all of the builds we are going to move or remove D<em class="markup--em markup--p-em">eploy to Bitrise.io </em>step completely as an experiment. <br>Also, D<em class="markup--em markup--p-em">eploy to Bitrise.io </em>step is always triggered before unit tests but after APK creation. That way, only application (<em class="markup--em markup--p-em">uatRelease</em> APK for example) and the UI tests report are deployed.</p><p name="e5d1" id="e5d1" class="graf graf--p graf-after--p">Initially <em class="markup--em markup--p-em">deploy to Bitrise.io </em><strong class="markup--strong markup--p-strong">step took from 2.1 to 3.2 minutes</strong>.</p><figure name="54e4" id="54e4" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*rPm9k8yro36t8KsQr9f1oQ.png" data-width="679" data-height="51" src="https://cdn-images-1.medium.com/max/800/1*rPm9k8yro36t8KsQr9f1oQ.png"><figcaption class="imageCaption">Initially 3.2 min was total time per this step.</figcaption></figure><p name="13e4" id="13e4" class="graf graf--p graf-after--figure"><strong class="markup--strong markup--p-strong">After the changes it’s 0 minutes for some builds. It is ~8 seconds for most of them.</strong></p><figure name="5236" id="5236" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*QkK3s1i0SLgx5Zo1NBNw0A.png" data-width="679" data-height="48" src="https://cdn-images-1.medium.com/max/800/1*QkK3s1i0SLgx5Zo1NBNw0A.png"><figcaption class="imageCaption">That’s how quick it could be!</figcaption></figure><figure name="24fe" id="24fe" class="graf graf--figure graf-after--figure graf--trailing"><img class="graf-image" data-image-id="1*kFe06gXR1oM1b5rbmSR9BQ.jpeg" data-width="476" data-height="313" src="https://cdn-images-1.medium.com/max/800/1*kFe06gXR1oM1b5rbmSR9BQ.jpeg"><figcaption class="imageCaption">Oh yeah! Source: <a href="https://knowyourmeme.com/photos/988454-we-did-it-reddit" data-href="https://knowyourmeme.com/photos/988454-we-did-it-reddit" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">https://knowyourmeme.com/photos/988454-we-did-it-reddit</a></figcaption></figure></div></div></section><section name="84c9" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="91b0" id="91b0" class="graf graf--h3 graf--leading">Automation workflow</h3><p name="c09c" id="c09c" class="graf graf--p graf-after--h3">One of the low hanging fruits was to change what is being done <br>as a part of a particular workflow, since they all have different goals.<br>As I mentioned, we have <em class="markup--em markup--p-em">feature</em>, <em class="markup--em markup--p-em">automation</em>, <em class="markup--em markup--p-em">develop</em> and <em class="markup--em markup--p-em">release</em> workflow.<br>In our case, initially, all of the mentioned workflows had basically <br>the same setup. Why is this wrong? Because, as we said, workflows simply have different <strong class="markup--strong markup--p-strong">responsibilities</strong>.</p><h4 name="9b31" id="9b31" class="graf graf--h4 graf-after--p"><strong class="markup--strong markup--h4-strong">Understanding the differences in workflows</strong></h4><p name="b342" id="b342" class="graf graf--p graf-after--h4">I have already mentioned the <em class="markup--em markup--p-em">automation</em> workflow. It’s because it is special compared to other workflows. The only responsibility automation workflow has is to support Software Engineers in Test in writing and securing automation test suite. That simple conclusion means we can trim <br>several steps from it; in our case, APK and other artefacts creation <br>and deployment. We were also able to get rid of custom scripts we had there for the release app or “runtime” resources optimisations steps and beyond.</p><h4 name="908e" id="908e" class="graf graf--h4 graf-after--p">Results</h4><p name="c207" id="c207" class="graf graf--p graf-after--h4 graf--trailing">By doing this, the <em class="markup--em markup--p-em">automation </em>build is a fast feedback loop for the SETs.<br><strong class="markup--strong markup--p-strong">It takes around 10 minutes less than other builds.<br></strong>I believe it’s a huge win for the SETs team.</p></div></div></section><section name="a708" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="b672" id="b672" class="graf graf--h3 graf--leading">Investigating tools configuration</h3><p name="9154" id="9154" class="graf graf--p graf-after--h3">Here is a quick and simple story as an example. Our builds produced <em class="markup--em markup--p-em">uatDebug</em> and <em class="markup--em markup--p-em">uatRelease</em> APKs. UAT stands for ‘<a href="https://en.wikipedia.org/wiki/Acceptance_testing#User_acceptance_testing" data-href="https://en.wikipedia.org/wiki/Acceptance_testing#User_acceptance_testing" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">user acceptance testing</a>’ and it’s also a name of one of our environment s— environment with almost <em class="markup--em markup--p-em">production</em> setup but more over <em class="markup--em markup--p-em">development</em> data — and simply used for testing purposes. So, producing those two build sounds about right, doesn’t it? I started asking questions anyway. We were sure we need <em class="markup--em markup--p-em">uatRelease</em> for testing purposes. It makes sense since testing production ready app (<em class="markup--em markup--p-em">release</em>) using development data (<em class="markup--em markup--p-em">uat</em>) is one of the best practices. But why do we need <em class="markup--em markup--p-em">uatDebug </em>then?</p><h4 name="f0d0" id="f0d0" class="graf graf--h4 graf-after--p"><strong class="markup--strong markup--h4-strong">Trimming unused resources</strong></h4><p name="0797" id="0797" class="graf graf--p graf-after--h4">The sole reason was a misconfiguration of the <a href="https://www.charlesproxy.com/" data-href="https://www.charlesproxy.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Charles proxy</a> tool, which led testers to not being able to use proxy tools while testing <em class="markup--em markup--p-em">uatRelease </em>build variant. Famous<a href="https://developer.android.com/training/articles/security-config" data-href="https://developer.android.com/training/articles/security-config" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"> <em class="markup--em markup--p-em">network_security_config</em></a><em class="markup--em markup--p-em"> </em>file had been added to the project but it wasn’t working, since the build variant has to be <em class="markup--em markup--p-em">debuggable. </em>The quick fix was to add <em class="markup--em markup--p-em">android:debuggable</em> attribute to all <em class="markup--em markup--p-em">uat </em>builds. And since we’re not testing <em class="markup--em markup--p-em">uat</em> builds using any public channels — it’s secure enough.</p><h4 name="9658" id="9658" class="graf graf--h4 graf-after--p">Results</h4><p name="713c" id="713c" class="graf graf--p graf-after--h4 graf--trailing">A simple configuration fix to the existing toolset <strong class="markup--strong markup--p-strong">brought an 8 minutes time reduction to each build and fixed SETs headache.</strong></p></div></div></section><section name="4acf" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="93a6" id="93a6" class="graf graf--h3 graf--leading">All numbers together</h3><p name="49c4" id="49c4" class="graf graf--p graf-after--h3">In summary</p><ul class="postList"><li name="2651" id="2651" class="graf graf--li graf-after--p">Unit tests time <strong class="markup--strong markup--li-strong">down from 30 minutes to 3~6 minutes. </strong>Depends on build type.</li><li name="54ef" id="54ef" class="graf graf--li graf-after--li">Automation build cut off by <strong class="markup--strong markup--li-strong">another 10 minutes</strong> through removing a few unnecessary steps.</li><li name="860a" id="860a" class="graf graf--li graf-after--li">Artefacts deployment reduced <strong class="markup--strong markup--li-strong">from 2.1~3.2 minutes into 8 seconds!</strong></li><li name="b6ef" id="b6ef" class="graf graf--li graf-after--li">Fix to Charles configs gave us another <strong class="markup--strong markup--li-strong">8 minutes</strong> — due <em class="markup--em markup--li-em">uatDebug</em> build removal.</li></ul><p name="794f" id="794f" class="graf graf--p graf-after--li">We were able to shorten builds by between <strong class="markup--strong markup--p-strong">48 minutes and 34 minutes <br>per each build</strong>. That was a huge win and relief as you can imagine!</p><p name="2097" id="2097" class="graf graf--p graf-after--p graf--trailing">We obviously made some rookie mistakes. But the most important part <br>is to learn from them. We were able to adapt quickly and we’re providing other small improvements since then. It can’t happen on a daily basis because we also need to deliver <em class="markup--em markup--p-em">business value</em> to our clients — but with an appropriate plan in place, I’m sure you can do even more.</p></div></div></section><section name="a5ba" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="e5df" id="e5df" class="graf graf--h3 graf--leading">Tips and tricks beyond optimisations</h3><p name="456d" id="456d" class="graf graf--p graf-after--h3">Bitrise and its plugins’ documentation is quite limited. You will need to deep dive into the plugins code if you want to understand the platform fully. Plugins code is mostly open source — you can find links inside plugin documentation. In particular, review the<a href="https://github.com/bitrise-steplib/steps-gradle-unit-test/blob/master/main.go" data-href="https://github.com/bitrise-steplib/steps-gradle-unit-test/blob/master/main.go" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"> <em class="markup--em markup--p-em">main.go</em></a> file if you’re looking for attributes and parameters which could customise the build.</p><p name="785d" id="785d" class="graf graf--p graf-after--p">Use<a href="https://app.bitrise.io/cli" data-href="https://app.bitrise.io/cli" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"> Bitrise CLI</a> in your terminal in order to test configuration locally. It will save you a lot of time.</p><p name="d88c" id="d88c" class="graf graf--p graf-after--p">Have as granular CI steps as possible. Use <em class="markup--em markup--p-em">title </em>attribute extensively. Greater readability — greater control over time. Solid foundations are the first step for future optimisation.</p><p name="2fee" id="2fee" class="graf graf--p graf-after--p">Do what we haven’t done yet — introduce tools to measure build metrics automatically.</p><p name="bff5" id="bff5" class="graf graf--p graf-after--p">Leverage version control since Bitrise is <em class="markup--em markup--p-em">similar</em> to<a href="https://en.wikipedia.org/wiki/Infrastructure_as_code" data-href="https://en.wikipedia.org/wiki/Infrastructure_as_code" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"> infrastructure as a code</a>.</p><p name="4d90" id="4d90" class="graf graf--p graf-after--p">That’s a separate story but in Tigerspike, we <strong class="markup--strong markup--p-strong">optimised APK size by 13%</strong> during our internal hackathon day. You should be aware of best practises for Android app configuration. Get rid or optimise resources, configuration and APK size. These kinds of things are also impacting your build time: git pull, compilation and build time, tests, deploy time — these are some of many examples.</p><p name="2701" id="2701" class="graf graf--p graf-after--p">Listen. Observe. Experiment. Formulate a plan and adopt only what’s needed for your team. Good luck!</p><figure name="abaf" id="abaf" class="graf graf--figure graf-after--p graf--trailing"><img class="graf-image" data-image-id="1*BZQiSFYjEQF1yKdcpJuWXA.png" data-width="225" data-height="225" alt="Donald Duck says Thank you!" src="https://cdn-images-1.medium.com/max/800/1*BZQiSFYjEQF1yKdcpJuWXA.png"><figcaption class="imageCaption">Thanks! Source: <a href="http://123emoji.com/donald-duck-stickers-2-9606/" data-href="http://123emoji.com/donald-duck-stickers-2-9606/" class="markup--anchor markup--figure-anchor" rel="noopener" target="_blank">http://123emoji.com/donald-duck-stickers-2-9606/</a></figcaption></figure></div></div></section><section name="2de4" class="section section--body"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="118c" id="118c" class="graf graf--p graf--leading">I hope you like this piece. As you can see I love a fast feedback loop — <br>if you have any objections, comments or questions — please drop a comment or DM message.</p><p name="c07e" id="c07e" class="graf graf--p graf-after--p graf--trailing">The article showcases what we have done for one of our projects in<a href="https://tigerspike.com/" data-href="https://tigerspike.com/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"> Tigerspike</a>. We’re<a href="https://tigerspike.com/join-us/" data-href="https://tigerspike.com/join-us/" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"> hiring</a> — please mention my name! ;)</p></div></div></section><section name="5d34" class="section section--body section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><p name="87f4" id="87f4" class="graf graf--p graf--leading graf--trailing">If you want to reach me out, I’m based in Wrocław, Poland.<br>I’m also visiting London from time to time.<br>Here is my<a href="https://pl.linkedin.com/in/maciejmalak" data-href="https://pl.linkedin.com/in/maciejmalak" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"> LinkedIn</a> and<a href="https://twitter.com/monkeydevspl" data-href="https://twitter.com/monkeydevspl" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank"> Twitter</a>.</p></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@maciekmalak" class="p-author h-card">Maciek Malak</a> on <a href="https://medium.com/p/5a85e45a33dc"><time class="dt-published" datetime="2020-05-05T14:42:23.224Z">May 5, 2020</time></a>.</p><p><a href="https://medium.com/@maciekmalak/be-effective-with-bitrise-ci-for-android-lessons-i-learned-the-hard-way-5a85e45a33dc" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on June 5, 2025.</p></footer></article></body></html>